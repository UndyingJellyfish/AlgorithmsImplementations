using System;
using System.Collections.Generic;

namespace Graphs
{
    // 
    public class Node<TCost, TValue> : IEquatable<Node<TCost, TValue>> where TCost : struct, IComparable
    {
        public TValue Value { get; set; }
        public List<Edge<TCost, TValue>> Edges { get; set; }
        public TCost TotalDistance { get; set; }
        public Node<TCost, TValue> Predecessor { get; set; }
        
        public Node(TValue val)
        {
            Edges = new List<Edge<TCost, TValue>>();
            Value = val;
            SetTotalDistanceAsMaxValue();
            Predecessor = null;
        }

        public bool TryAddEdge(Edge<TCost, TValue> edge)
        {
            if (Edges.Exists(x => x.Equals(edge))) return false;

            Edges.Add(edge);
            return true;
        }

        public void AddEdge(Edge<TCost, TValue> edge)
        {
            if (!TryAddEdge(edge)) throw new Exception("Edge is already added, cannot add same edge twice.");
        }


        public void SetTotalDistanceAsMaxValue()
        {
            // reflection solution found at:
            // https://stackoverflow.com/questions/18180674/detect-maxvalue-of-generic-parameter
            if (!typeof(TCost).IsValueType) throw new Exception("TCost is not a value type. Check the type constraints.");

            var temp = typeof(TCost).GetField("MaxValue").GetValue(null);

            TotalDistance = (TCost) Convert.ChangeType(temp, typeof(TCost));

            #region Possibly useless code
            /*
            var distanceType = typeof(TCost).ToString();
            switch (distanceType)
            {
                case "sbyte":
                    TotalDistance = (TCost) Convert.ChangeType(sbyte.MaxValue, typeof(TCost));
                    break;
                case "byte":
                    TotalDistance = (TCost) Convert.ChangeType(byte.MaxValue, typeof(TCost));
                    break;
                case "char":
                    TotalDistance = (TCost) Convert.ChangeType(char.MaxValue, typeof(TCost));
                    break;
                case "short":
                    TotalDistance = (TCost) Convert.ChangeType(short.MaxValue, typeof(TCost));
                    break;
                case "ushort":
                    TotalDistance = (TCost) Convert.ChangeType(ushort.MaxValue, typeof(TCost));
                    break;
                case "int":
                    TotalDistance = (TCost) Convert.ChangeType(int.MaxValue, typeof(TCost));
                    break;
                case "unit":
                    TotalDistance = (TCost) Convert.ChangeType(uint.MaxValue, typeof(TCost));
                    break;
                case "long":
                    TotalDistance = (TCost) Convert.ChangeType(long.MaxValue, typeof(TCost));
                    break;
                case "ulong":
                    TotalDistance = (TCost) Convert.ChangeType(ulong.MaxValue, typeof(TCost));
                    break;
                case "float":
                    TotalDistance = (TCost) Convert.ChangeType(float.MaxValue, typeof(TCost));
                    break;
                case "double":
                    TotalDistance = (TCost) Convert.ChangeType(double.MaxValue, typeof(TCost));
                    break;
                case "decimal":
                    TotalDistance = (TCost) Convert.ChangeType(decimal.MaxValue, typeof(TCost));
                    break;
                default:
                    throw new InvalidCastException("Could not find a struct that matched. Check the type constraints.");
            }
            */
            #endregion

        }

        public void SetTotalDistanceAsDefaultValue()
        {
            if (!typeof(TCost).IsValueType) throw new Exception("TCost is not a value type. Check the type constraints.");

            var temp = default(TCost);

            TotalDistance = (TCost)Convert.ChangeType(temp, typeof(TCost));
        }

        public override string ToString()
        {
            return $"Distance: {TotalDistance}. Value: {Value.ToString()}. Predecessor value: {Predecessor.Value}";
        }

        // Code below was autogenerated by ReSharper as an implementation for the IEquatable interface
        // This is untested and really not be used in favour of bitwise comparison if you want to be 100 % sure
        public bool Equals(Node<TCost, TValue> other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;
            return EqualityComparer<TValue>.Default.Equals(Value, other.Value) && Equals(Edges, other.Edges) && TotalDistance.Equals(other.TotalDistance) && Equals(Predecessor, other.Predecessor);
        }

        public override bool Equals(object obj)
        {
            if (obj is null) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == this.GetType() && Equals((Node<TCost, TValue>) obj);
        }

        public override int GetHashCode()
        { 
            unchecked
            {
                var hashCode = EqualityComparer<TValue>.Default.GetHashCode(Value);
                hashCode = (hashCode * 397) ^ Edges.GetHashCode();
                hashCode = (hashCode * 397) ^ TotalDistance.GetHashCode();
                hashCode = (hashCode * 397) ^ (Predecessor != null ? Predecessor.GetHashCode() : 0);
                return hashCode;
            }
        }
    }
}