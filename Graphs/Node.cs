using System;
using System.Collections.Generic;

namespace Graphs
{
    public class Node<TCost, TValue> : IEquatable<Node<TCost, TValue>> where TCost : struct, IComparable
    {
        public TValue Value { get; set; }
        public List<Edge<TCost, TValue>> OutgoingEdges { get; set; }
        public TCost TotalDistance { get; set; }
        public Node<TCost, TValue> Predecessor { get; set; }
        
        public Node(TValue val)
        {
            OutgoingEdges = new List<Edge<TCost, TValue>>();
            Value = val;
            SetTotalDistanceAsMaxValue();
            Predecessor = null;
        }

        public bool TryAddEdge(Edge<TCost, TValue> edge)
        {
            if (OutgoingEdges.Exists(x => x.Equals(edge))) return false;

            OutgoingEdges.Add(edge);
            return true;
        }

        public void AddEdge(Edge<TCost, TValue> edge)
        {
            if (!TryAddEdge(edge)) throw new Exception("Edge is already added, cannot add same edge twice.");
        }

        public void SetTotalDistanceAsMaxValue()
        {
            // reflection solution found at:
            // https://stackoverflow.com/questions/18180674/detect-maxvalue-of-generic-parameter
            if (!typeof(TCost).IsValueType) throw new Exception("TCost is not a value type. Check the type constraints.");

            var temp = typeof(TCost).GetField("MaxValue").GetValue(null);

            TotalDistance = (TCost) Convert.ChangeType(temp, typeof(TCost));
        }

        public void SetTotalDistanceAsDefaultValue()
        {
            if (!typeof(TCost).IsValueType) throw new Exception("TCost is not a value type. Check the type constraints.");

            var temp = default(TCost);

            TotalDistance = (TCost)Convert.ChangeType(temp, typeof(TCost));
        }

        public override string ToString()
        {
            return $"Distance: {TotalDistance}. Value: {Value.ToString()}. Predecessor value: {Predecessor.Value}";
        }

        // Code below was autogenerated by ReSharper as an implementation for the IEquatable interface
        // This is untested and really not be used in favour of bitwise comparison if you want to be 100 % sure
        public bool Equals(Node<TCost, TValue> other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;
            return EqualityComparer<TValue>.Default.Equals(Value, other.Value) && Equals(OutgoingEdges, other.OutgoingEdges) && TotalDistance.Equals(other.TotalDistance) && Equals(Predecessor, other.Predecessor);
        }

        public override bool Equals(object obj)
        {
            if (obj is null) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == this.GetType() && Equals((Node<TCost, TValue>) obj);
        }

        public override int GetHashCode()
        { 
            unchecked
            {
                var hashCode = EqualityComparer<TValue>.Default.GetHashCode(Value);
                hashCode = (hashCode * 397) ^ OutgoingEdges.GetHashCode();
                hashCode = (hashCode * 397) ^ TotalDistance.GetHashCode();
                hashCode = (hashCode * 397) ^ (Predecessor != null ? Predecessor.GetHashCode() : 0);
                return hashCode;
            }
        }
    }
}